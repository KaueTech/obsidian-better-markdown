/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ExtendedMarkdownSyntax
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");
var import_view10 = require("@codemirror/view");

// src/editorPlugins/extendedFormattingPlugin.ts
var import_view7 = require("@codemirror/view");
var import_obsidian2 = require("obsidian");

// src/editorPlugins/stateFields/extendedFormattingField.ts
var import_state = require("@codemirror/state");
var import_language4 = require("@codemirror/language");

// src/utils/codemirror/checkSelectionOverlap.ts
function checkSelectionOverlap(selection, from, to) {
  if (!selection) {
    return false;
  }
  for (const range of selection.ranges) {
    if (range.to >= from && range.from <= to) {
      return true;
    }
    return false;
  }
  return false;
}

// src/utils/codemirror/isCodeblock.ts
var import_language = require("@codemirror/language");
function isCodeblock(view, from, to) {
  let isCodeblock2 = false;
  (0, import_language.syntaxTree)(view.state).iterate({
    from,
    to,
    enter: (node) => {
      if (/^inline-code/.test(node.name) || node.name == "HyperMD-codeblock_HyperMD-codeblock-bg") {
        isCodeblock2 = true;
        return false;
      }
    }
  });
  return isCodeblock2;
}

// src/utils/codemirror/isHighlight.ts
var import_language2 = require("@codemirror/language");

// src/utils/codemirror/isRestrictedRange.ts
var import_language3 = require("@codemirror/language");

// src/utils/codemirror/isColumnSeparator.ts
function isColumnSeparator(tree, pos) {
  return /hmd-table-sep/.test(tree.resolveInner(pos, 1).name);
}

// src/utils/codemirror/isRestrictedPos.ts
function isRestrictedPos(tree, pos) {
  return /(?:inline-code)|(?:tag)|(?:HyperMD-codeblock)|(?:footref)|(?:hmd-internal-link)|(?:hmd-footnote)|(?:math)|(?:hmd-codeblock)|(?:formatting-strikethrough)/.test(tree.resolveInner(pos, 1).name);
}

// src/utils/codemirror/isTable.ts
function isTable(tree, pos) {
  let isTable2 = false;
  tree.iterate({
    from: pos,
    to: pos,
    enter: (node) => {
      if (/table/.test(node.name)) {
        isTable2 = true;
        return false;
      }
    }
  });
  return isTable2;
}

// src/regExps/delimRegExps.ts
var delimRegExps = /* @__PURE__ */ new Map([
  ["u" /* U */, {
    openingDelim: new RegExp("(?:(?<!\\\\)|(?<=(?<!\\\\)(?:\\\\{2})+))\\+\\+(?![\\+\\s]|$)", "gd"),
    closingDelim: new RegExp("(?:(?<![\\s\\\\]|^)|(?<=(?<!\\\\)(?:\\\\{2})+))\\+\\+", "gd"),
    length: 2
  }],
  ["sup" /* Sup */, {
    openingDelim: new RegExp("(?:(?<!\\\\)|(?<=(?<!\\\\)(?:\\\\{2})+))\\^(?![\\^\\s]|$)", "gd"),
    closingDelim: new RegExp("(?:(?<![\\s\\\\]|^)|(?<=(?<!\\\\)(?:\\\\{2})+))\\^", "gd"),
    length: 1
  }],
  ["sub" /* Sub */, {
    openingDelim: new RegExp("(?:(?<!\\\\)|(?<=(?<!\\\\)(?:\\\\{2})+))~(?![~\\s]|$)", "gd"),
    closingDelim: new RegExp("(?:(?<![\\s\\\\]|^)|(?<=(?<!\\\\)(?:\\\\{2})+))~", "gd"),
    length: 1
  }],
  ["spoiler" /* Spoiler */, {
    openingDelim: new RegExp("(?:(?<!\\\\)|(?<=(?<!\\\\)(?:\\\\{2})+))\\|\\|(?![|\\s]|$)", "gd"),
    closingDelim: new RegExp("(?:(?<![\\s\\\\]|^)|(?<=(?<!\\\\)(?:\\\\{2})+))\\|\\|", "gd"),
    length: 2
  }]
]);

// src/regExps/postProcessorDelimRegExps.ts
var postProcessorDelimRegExps = /* @__PURE__ */ new Map([
  ["u" /* U */, {
    openingDelim: new RegExp("\\+\\+(?![\\s]|$|(?:<br>\\n?))", "gd"),
    closingDelim: new RegExp("(?<![\\s]|(?:<br>\\n?))\\+\\+", "gd"),
    raw: {
      openingDelim: new RegExp("((?<!\\\\)(?:\\\\{2})*\\\\)?(\\+(\\\\)?\\+)(?!$|\\s)(?=(\\+)?)", "gd"),
      closingDelim: new RegExp("(?:((?<!\\\\)(?:\\\\{2})*(?<!\\s)\\\\)|(?<![\\\\\\s])|((?<!\\\\)(?:\\\\{2})+))(\\+(\\\\)?\\+)", "gd")
    },
    length: 2
  }],
  ["sup" /* Sup */, {
    openingDelim: new RegExp("\\^(?![\\s]|$|(?:<br>\\n?))", "gd"),
    closingDelim: new RegExp("(?<![\\s]|(?:<br>\\n?))\\^", "gd"),
    raw: {
      openingDelim: new RegExp("((?<!\\\\)(?:\\\\{2})*\\\\)?(\\^()?)(?!$|\\s)(?=(\\^)?)", "gd"),
      closingDelim: new RegExp("(?:((?<!\\\\)(?:\\\\{2})*(?<!\\s)\\\\)|(?<![\\\\\\s])|((?<!\\\\)(?:\\\\{2})+))(\\^()?)", "gd")
    },
    length: 1
  }],
  ["sub" /* Sub */, {
    openingDelim: new RegExp("~(?![\\s]|$|(?:<br>\\n?))", "gd"),
    closingDelim: new RegExp("(?<![\\s]|(?:<br>\\n?))~", "gd"),
    raw: {
      openingDelim: new RegExp("((?<!\\\\)(?:\\\\{2})*\\\\)?(~()?)(?!$|\\s)(?=(~)?)", "gd"),
      closingDelim: new RegExp("(?:((?<!\\\\)(?:\\\\{2})*(?<!\\s)\\\\)|(?<![\\\\\\s])|((?<!\\\\)(?:\\\\{2})+))(~()?)", "gd")
    },
    length: 1
  }],
  ["spoiler" /* Spoiler */, {
    openingDelim: new RegExp("\\|\\|(?![\\s]|$|(?:<br>\\n?))", "gd"),
    closingDelim: new RegExp("(?<![\\s]|(?:<br>\\n?))\\|\\|", "gd"),
    raw: {
      openingDelim: new RegExp("((?<!\\\\)(?:\\\\{2})*\\\\)?(\\|(\\\\)?\\|)(?!$|\\s)(?=(\\|)?)", "gd"),
      closingDelim: new RegExp("(?:((?<!\\\\)(?:\\\\{2})*(?<!\\s)\\\\)|(?<![\\\\\\s])|((?<!\\\\)(?:\\\\{2})+))(\\|(\\\\)?\\|)", "gd")
    },
    length: 2
  }]
]);

// src/editorPlugins/stateFields/extendedFormattingField.ts
function getDelimiterFromEditor(doc, tree, type, openingDelim, closingDelim, previous) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let text = doc.toString(), doubleNewLineChar = /\n\n+/g, verticalBarChar = /(?<!^)\|/g, delimPosCollection = [];
  if (previous) {
    delimPosCollection = previous.posCollection;
    let { from, delimLength } = previous, lastIndex = (
      /* type == "spoiler" ? doc.lineAt(from).from : */
      from - delimLength
    );
    delimPosCollection.length && delimPosCollection.findLast((delimPos, index, collection) => {
      if (from >= delimPos[1]) {
        if (from < delimPos[3] || from == delimPos[3] && delimPos[2] == delimPos[3]) {
          lastIndex = delimPos[0];
          collection.splice(index);
        } else if (from - delimPos[3] < delimLength) {
          lastIndex = delimPos[3];
          collection.splice(index + 1);
        } else {
          collection.splice(index + 1);
        }
        return true;
      } else if (index == 0) {
        collection.splice(0);
        return true;
      }
    });
    openingDelim.lastIndex = doubleNewLineChar.lastIndex = lastIndex;
  }
  mainLoop: for (let openingPos = (_a = openingDelim.exec(text)) == null ? void 0 : _a.indices[0], endLineOffset = (_c = (_b = doubleNewLineChar.exec(text)) == null ? void 0 : _b.index) != null ? _c : text.length; openingPos; openingPos = (_d = openingDelim.exec(text)) == null ? void 0 : _d.indices[0]) {
    if (openingPos[1] > tree.length) {
      break;
    }
    if (isRestrictedPos(tree, openingPos[0])) {
      continue;
    }
    let delimPos = [0, 0, 0, 0];
    closingDelim.lastIndex = openingPos[1];
    let endCellOffset = 0, currentLine = doc.lineAt(openingPos[0]), isTableRow = isTable(tree, openingPos[0]);
    if (isTableRow) {
      if (type == "spoiler") {
        openingDelim.lastIndex = currentLine.to;
        continue;
      }
      for (verticalBarChar.lastIndex = openingPos[0] - currentLine.from; ; ) {
        let verticalBarPos = (_e = verticalBarChar.exec(currentLine.text)) == null ? void 0 : _e.index;
        if (!verticalBarPos) {
          endCellOffset = currentLine.to;
          break;
        } else if (isColumnSeparator(tree, verticalBarPos + currentLine.from)) {
          endCellOffset = verticalBarPos + currentLine.from;
          break;
        }
      }
    }
    if (openingDelim.lastIndex > endLineOffset) {
      doubleNewLineChar.lastIndex = openingDelim.lastIndex;
      endLineOffset = ((_f = doubleNewLineChar.exec(text)) == null ? void 0 : _f.index) || text.length;
    }
    [delimPos[0], delimPos[1]] = openingPos;
    while (true) {
      let closingPos = (_g = closingDelim.exec(text)) == null ? void 0 : _g.indices[0];
      if (!closingPos || closingDelim.lastIndex > endLineOffset || isTableRow && closingDelim.lastIndex > endCellOffset) {
        delimPos[2] = delimPos[3] = openingDelim.lastIndex = isTableRow ? endCellOffset : endLineOffset;
        closingDelim.lastIndex > endLineOffset && (endLineOffset = ((_h = doubleNewLineChar.exec(text)) == null ? void 0 : _h.index) || text.length);
      } else {
        if (isRestrictedPos(tree, closingPos[0])) {
          continue;
        }
        openingDelim.lastIndex = closingPos[1];
        [delimPos[2], delimPos[3]] = closingPos;
      }
      break;
    }
    delimPosCollection.push(delimPos);
  }
  closingDelim.lastIndex && (closingDelim.lastIndex = 0);
  return delimPosCollection;
}
var extendedFormattingField = import_state.StateField.define({
  create(state) {
    let delimField = /* @__PURE__ */ new Map();
    let tree = (0, import_language4.syntaxTree)(state);
    delimRegExps.forEach((value, type) => {
      delimField.set(type, getDelimiterFromEditor(state.doc, tree, type, value.openingDelim, value.closingDelim));
    });
    return { delimField, treeLength: tree.length };
  },
  update(value, transaction) {
    let tree = (0, import_language4.syntaxTree)(transaction.state);
    transaction.effects.forEach((value2) => {
      var _a, _b;
      tree = (_b = (_a = value2.value) == null ? void 0 : _a.tree) != null ? _b : tree;
    });
    if (transaction.docChanged || tree.length != value.treeLength) {
      let from = Math.min(value.treeLength, tree.length);
      value.treeLength = tree.length;
      transaction.changes.iterChangedRanges((fromA) => {
        from = Math.min(from, fromA);
      }, false);
      value.delimField.forEach((posCollection, type) => {
        let { openingDelim, closingDelim, length } = delimRegExps.get(type);
        getDelimiterFromEditor(transaction.state.doc, tree, type, openingDelim, closingDelim, { from, delimLength: length, posCollection });
      });
    }
    return value;
  }
});

// src/editorPlugins/stateFields/customHighlightField.ts
var import_state2 = require("@codemirror/state");
var import_language5 = require("@codemirror/language");
function getHighlight(doc, tree, previous) {
  let text = doc.toString();
  let hlChecker = /highlight/;
  let hlDelim = /(?:(?<!\\)|(?<=(?<!\\)(?:\\{2})+))==+(?=(?:\{([\w\d\-]+)\})|[^=\s])/g;
  let hlCollection = [];
  if (previous) {
    hlCollection = previous.hlCollection;
    let { from } = previous, lastIndex = from - 2;
    hlCollection.length && hlCollection.findLast((hlProp, index, collection) => {
      if (from >= hlProp[1]) {
        if (from < hlProp[3] || from == hlProp[3]) {
          lastIndex = hlProp[0];
          collection.splice(index);
        } else {
          collection.splice(index + 1);
        }
        return true;
      } else if (index == 0) {
        collection.splice(0);
        return true;
      }
    });
    hlDelim.lastIndex = lastIndex;
  }
  for (let hlMatch = hlDelim.exec(text), node; hlMatch && (node = tree.resolveInner(hlMatch.index, 1)); hlMatch = hlDelim.exec(text)) {
    let openingFrom = node.from;
    if (openingFrom > tree.length) {
      break;
    }
    if (!hlChecker.test(node.name)) {
      continue;
    }
    let to;
    while (true) {
      to = node.to;
      node = tree.resolveInner(node.to, 1);
      if (!hlChecker.test(node.name)) {
        break;
      }
    }
    let lastNode = tree.resolveInner(to, -1);
    let innerHlEnd = /formatting-highlight/.test(lastNode.name) ? lastNode.from : to;
    hlCollection.push([openingFrom, hlDelim.lastIndex, innerHlEnd, to, hlMatch[1]]);
    hlDelim.lastIndex = to;
  }
  return hlCollection;
}
var customHighlightField = import_state2.StateField.define({
  create(state) {
    let tree = (0, import_language5.syntaxTree)(state);
    return {
      hlCollection: getHighlight(state.doc, tree),
      treeLength: tree.length
    };
  },
  update(value, transaction) {
    let tree = (0, import_language5.syntaxTree)(transaction.state);
    transaction.effects.forEach((value2) => {
      var _a, _b;
      tree = (_b = (_a = value2.value) == null ? void 0 : _a.tree) != null ? _b : tree;
    });
    if (transaction.docChanged || tree.length != value.treeLength) {
      let from = Math.min(value.treeLength, tree.length);
      value.treeLength = tree.length;
      transaction.changes.iterChangedRanges((fromA) => {
        from = Math.min(from, fromA);
      }, false);
      getHighlight(transaction.state.doc, tree, { from, hlCollection: value.hlCollection });
    }
    return value;
  }
});

// src/editorPlugins/widgets/ColorButton.ts
var import_view = require("@codemirror/view");
var import_obsidian = require("obsidian");
var ColorButton = class extends import_view.WidgetType {
  constructor(color = "default", markerFrom, markerTo, outerFrom, outerTo, innerFrom, innerTo) {
    super();
    __publicField(this, "color");
    __publicField(this, "markerFrom");
    __publicField(this, "markerTo");
    __publicField(this, "menu");
    __publicField(this, "outerFrom");
    __publicField(this, "outerTo");
    __publicField(this, "innerFrom");
    __publicField(this, "innerTo");
    __publicField(this, "colors", ["red", "orange", "yellow", "green", "cyan", "blue", "purple", "pink", "accent", "default"]);
    this.color = color;
    this.markerFrom = markerFrom;
    this.markerTo = markerTo;
    this.outerFrom = outerFrom;
    this.outerTo = outerTo;
    this.innerFrom = innerFrom;
    this.innerTo = innerTo;
  }
  eq(other) {
    return other.color == this.color;
  }
  toDOM(view) {
    let btn = document.createElement("span");
    btn.setAttribute("aria-hidden", "true");
    btn.className = "cmx-color-btn";
    btn.onclick = (evt) => {
      view.dispatch({
        selection: {
          anchor: this.markerFrom,
          head: this.markerTo
        }
      });
    };
    btn.onmouseover = (evt) => {
      if (this.menu != null) {
        return;
      }
      this.menu = new import_obsidian.Menu();
      this.menu.dom.addClass("es-highlight-colors-modal");
      this.colors.forEach((color) => {
        this.menu.addItem((item) => {
          item.setTitle(color).onClick((evt2) => {
            view.dispatch({
              changes: {
                from: this.markerFrom,
                to: this.markerTo,
                insert: color != "default" ? `{${color}}` : ""
              }
            });
          }).setIcon("palette");
          item.dom.addClass(`es-item-${color}`);
        });
      });
      this.menu.addItem((item) => {
        item.setTitle("Remove").setIcon("ban").onClick((evt2) => {
          view.dispatch({
            changes: [{
              from: this.outerFrom,
              to: this.markerTo,
              insert: ""
            }, {
              from: this.innerTo,
              to: this.outerTo,
              insert: ""
            }]
          });
        });
      });
      const rect = btn.getBoundingClientRect();
      this.menu.showAtPosition({ x: rect.left, y: rect.bottom });
    };
    return btn;
  }
  ignoreEvent() {
    return false;
  }
};

// src/editorPlugins/widgets/HiddenWidget.ts
var import_view2 = require("@codemirror/view");
var HiddenWidget = class extends import_view2.WidgetType {
  constructor(formattingMark) {
    super();
    __publicField(this, "mark");
    this.mark = formattingMark;
  }
  eq(other) {
    return other.mark == this.mark;
  }
  toDOM(view) {
    return document.createElement("span");
  }
};

// src/editorPlugins/decorators/alignerDecorators.ts
var import_view3 = require("@codemirror/view");
var alignerDecorators = [
  import_view3.Decoration.line({
    class: "cmx-align-left",
    query: /(?<=^|^#{1,6} +)!left!/gm,
    style: "text-align: left;",
    marker: import_view3.Decoration.mark({ class: "cmx-align-left-marker" })
  }),
  import_view3.Decoration.line({
    class: "cmx-align-right",
    query: /(?<=^|^#{1,6} +)!right!/gm,
    style: "text-align: right;",
    marker: import_view3.Decoration.mark({ class: "cmx-align-right-marker" })
  }),
  import_view3.Decoration.line({
    class: "cmx-align-center",
    query: /(?<=^|^#{1,6} +)!center!/gm,
    style: "text-align: center;",
    marker: import_view3.Decoration.mark({ class: "cmx-align-center-marker" })
  }),
  import_view3.Decoration.line({
    class: "cmx-align-justify",
    query: /(?<=^|^#{1,6} +)!justify!/gm,
    style: "text-align: justify;",
    marker: import_view3.Decoration.mark({ class: "cmx-align-justify-marker" })
  })
];

// src/editorPlugins/decorators/highlightDecorator.ts
var import_view4 = require("@codemirror/view");
var highlightDecorator = {
  class: "cmx-highlight cmx-highlight",
  markerDeco: import_view4.Decoration.mark({ class: "cmx-highlight-marker" })
};

// src/editorPlugins/decorators/formattingDecorators.ts
var import_view5 = require("@codemirror/view");
var formattingDecorators = /* @__PURE__ */ new Map([
  ["u" /* U */, import_view5.Decoration.mark({ class: "cmx-underline", delimDeco: import_view5.Decoration.mark({ class: "cmx-underline cmx-formatting-underline" }) })],
  ["sup" /* Sup */, import_view5.Decoration.mark({ class: "cmx-superscript", delimDeco: import_view5.Decoration.mark({ class: "cmx-superscript cmx-formatting-superscript" }) })],
  ["sub" /* Sub */, import_view5.Decoration.mark({ class: "cmx-subscript", delimDeco: import_view5.Decoration.mark({ class: "cmx-subscript cmx-formatting-subscript" }) })],
  ["spoiler" /* Spoiler */, import_view5.Decoration.mark({ class: "cmx-spoiler", delimDeco: import_view5.Decoration.mark({ class: "cmx-spoiler cmx-formatting-spoiler" }) })]
]);

// src/editorPlugins/decorators/hiddenSpoiler.ts
var import_view6 = require("@codemirror/view");
var hiddenSpoiler = import_view6.Decoration.mark({
  class: "cmx-spoiler cmx-spoiler-hidden"
});

// src/editorPlugins/extendedFormattingPlugin.ts
var ExtendedFormatting = class {
  constructor(view) {
    __publicField(this, "decorations");
    __publicField(this, "isLivePreview");
    this.decorations = this.buildDecorations(view);
    this.isLivePreview = view.state.field(import_obsidian2.editorLivePreviewField);
  }
  update(update) {
    if (update.state.field(import_obsidian2.editorLivePreviewField) == this.isLivePreview) {
      this.decorations = this.buildDecorations(update.view);
    }
    this.isLivePreview = update.state.field(import_obsidian2.editorLivePreviewField);
    if (update.docChanged || update.selectionSet) {
      this.decorations = this.buildDecorations(update.view);
    }
  }
  buildDecorations(view) {
    let newDecorations = [];
    view.state.field(extendedFormattingField).delimField.forEach((posCollection, type) => {
      if (posCollection.length === 0) {
        return;
      }
      ;
      let decorator = formattingDecorators.get(type);
      let delimDecorator = decorator == null ? void 0 : decorator.spec.delimDeco;
      posCollection.forEach((pos) => {
        let hasClosingDelim = pos[2] != pos[3];
        if (type != "spoiler") {
          newDecorations.push(decorator.range(pos[1], pos[2]));
        }
        newDecorations.push(delimDecorator.range(pos[0], pos[1]));
        if (hasClosingDelim) {
          newDecorations.push(delimDecorator.range(pos[2], pos[3]));
        }
        if ((!view.hasFocus || !checkSelectionOverlap(view.state.selection, pos[0], pos[3])) && this.isLivePreview) {
          type == "spoiler" && newDecorations.push(hiddenSpoiler.range(pos[1], pos[2]));
          this.hideDelim(newDecorations, delimDecorator, pos, hasClosingDelim);
        } else if (type == "spoiler") {
          newDecorations.push(decorator.range(pos[1], pos[2]));
        }
      });
    });
    return import_view7.Decoration.set(newDecorations, true);
  }
  hideDelim(decorations, decorator, pos, hasClosingDelim) {
    let hiddenDelim = import_view7.Decoration.replace({
      widget: new HiddenWidget(decorator)
    });
    decorations.push(hiddenDelim.range(pos[0], pos[1]));
    if (hasClosingDelim) {
      decorations.push(hiddenDelim.range(pos[2], pos[3]));
    }
  }
};
var extendedFormattingPlugin = import_view7.ViewPlugin.fromClass(ExtendedFormatting, {
  decorations: (value) => value.decorations
});

// src/editorPlugins/alignerPlugin.ts
var import_view8 = require("@codemirror/view");
var import_search = require("@codemirror/search");
var import_obsidian3 = require("obsidian");
var Aligner = class {
  constructor(view) {
    __publicField(this, "decorations");
    __publicField(this, "isLivePreview");
    this.decorations = this.buildDecorations(view);
    this.isLivePreview = view.state.field(import_obsidian3.editorLivePreviewField);
  }
  update(update) {
    if (update.state.field(import_obsidian3.editorLivePreviewField) == this.isLivePreview) {
      this.decorations = this.buildDecorations(update.view);
    }
    this.isLivePreview = update.state.field(import_obsidian3.editorLivePreviewField);
    if (update.docChanged || update.selectionSet) {
      this.decorations = this.buildDecorations(update.view);
    }
  }
  buildDecorations(view) {
    let newDecorations = [];
    alignerDecorators.forEach((deco) => {
      let searchCursor = new import_search.RegExpCursor(view.state.doc, deco.spec.query).next();
      if (searchCursor.done) {
        return newDecorations;
      }
      ;
      let marker = deco.spec.marker;
      while (!searchCursor.done) {
        let [from, to] = [searchCursor.value.from, searchCursor.value.to];
        if (!isCodeblock(view, from, to)) {
          let linePosFrom = view.state.doc.lineAt(from).from;
          newDecorations.push(deco.range(linePosFrom, linePosFrom));
          newDecorations.push(marker.range(from, to));
          if (!checkSelectionOverlap(view.state.selection, from, to) && this.isLivePreview) {
            this.hideMarker(newDecorations, marker, from, to);
          }
        }
        searchCursor.next();
      }
    });
    return import_view8.Decoration.set(newDecorations, true);
  }
  hideMarker(decorations, marker, from, to) {
    let hiddenMarker = import_view8.Decoration.replace({
      widget: new HiddenWidget(marker)
    });
    decorations.push(hiddenMarker.range(from, to));
  }
};
var alignerPlugin = import_view8.ViewPlugin.fromClass(Aligner, {
  decorations: (value) => value.decorations
});

// src/editorPlugins/customHighlightPlugin.ts
var import_view9 = require("@codemirror/view");
var import_obsidian4 = require("obsidian");
var CustomHighlight = class {
  constructor(view) {
    __publicField(this, "decorations");
    __publicField(this, "isLivePreview");
    this.decorations = this.buildDecorations(view);
    this.isLivePreview = view.state.field(import_obsidian4.editorLivePreviewField);
  }
  update(update) {
    if (update.state.field(import_obsidian4.editorLivePreviewField) == this.isLivePreview) {
      this.decorations = this.buildDecorations(update.view);
    }
    this.isLivePreview = update.state.field(import_obsidian4.editorLivePreviewField);
    if (update.docChanged || update.selectionSet) {
      this.decorations = this.buildDecorations(update.view);
    }
  }
  buildDecorations(view) {
    let newDecorations = [];
    let marker = highlightDecorator.markerDeco;
    view.state.field(customHighlightField).hlCollection.forEach((hl) => {
      let [outerFrom, innerFrom, innerTo, outerTo, color] = [...hl];
      let markerLength = color ? color.length + 2 : 0;
      newDecorations.push(
        import_view9.Decoration.mark({ class: `${highlightDecorator.class}-${color != null ? color : "default"}` }).range(outerFrom, outerTo),
        import_view9.Decoration.mark({ class: `${highlightDecorator.class}-first-letter` }).range(innerFrom + markerLength, innerFrom + markerLength + 1),
        import_view9.Decoration.mark({ class: `${highlightDecorator.class}-last-letter` }).range(innerTo - 1, innerTo)
      );
      if (checkSelectionOverlap(view.state.selection, outerFrom, outerTo) || !this.isLivePreview) {
        newDecorations.push(import_view9.Decoration.widget({ widget: new ColorButton(
          color,
          innerFrom,
          innerFrom + markerLength,
          outerFrom,
          outerTo,
          innerFrom,
          innerTo
        ), side: 1 }).range(innerFrom));
      }
      if (color && !(checkSelectionOverlap(view.state.selection, innerFrom, innerFrom + markerLength) || !this.isLivePreview)) {
        this.hideMarker(newDecorations, marker, innerFrom, innerFrom + markerLength);
      }
    });
    return import_view9.Decoration.set(newDecorations, true);
  }
  hideMarker(decorations, marker, from, to) {
    let hiddenMarker = import_view9.Decoration.replace({
      widget: new HiddenWidget(marker)
    });
    decorations.push(
      hiddenMarker.range(from, to)
    );
  }
};
var customHighlightPlugin = import_view9.ViewPlugin.fromClass(CustomHighlight, {
  decorations: (value) => value.decorations
});

// src/postProcessor/AlignerPostProcessor.ts
var AlignerPostProcessor = class {
  constructor() {
    __publicField(this, "targetedElements", "p, h1, h2, h3, h4, h5, h6, td, th, .callout-title-inner");
    __publicField(this, "format", (el) => {
      var _a, _b;
      let alignMark = /^!((?:left)|(?:right)|(?:center)|(?:justify))!/;
      let alignMarkExecArr;
      if (((_a = el.parentElement) == null ? void 0 : _a.tagName) == "BLOCKQUOTE") {
        return;
      }
      if ((_b = el.parentElement) == null ? void 0 : _b.hasClass("callout-content")) {
        alignMark = /^ *!((?:left)|(?:right)|(?:center)|(?:justify))!/;
        alignMarkExecArr = alignMark.exec(el.innerHTML);
      } else if (el.toString() == "[object HTMLHeadingElement]" && el.childNodes[1].nodeType == 3) {
        alignMarkExecArr = alignMark.exec(el.childNodes[1].textContent);
      } else {
        alignMarkExecArr = alignMark.exec(el.innerHTML);
      }
      if (alignMarkExecArr) {
        el.innerHTML = el.innerHTML.replace(alignMarkExecArr[0], "");
        if (el.hasClass("callout-title-inner")) {
          el.parentElement.style.justifyContent = alignMarkExecArr[1] != "justify" ? alignMarkExecArr[1] : "space-between";
        } else {
          el.style.textAlign = alignMarkExecArr[1];
        }
      }
    });
    __publicField(this, "postProcess", (container) => {
      if (container.classList.contains("table-cell-wrapper")) {
        this.format(container);
      } else {
        container.querySelectorAll(this.targetedElements).forEach((el) => {
          this.format(el);
        });
      }
    });
  }
};

// src/postProcessor/CustomHighlightPostProcessor.ts
var CustomHighlightPostProcessor = class {
  constructor() {
    __publicField(this, "format", (el) => {
      let markElements = el.querySelectorAll("mark");
      let colorMark = /^\{([\w\d\-_]+)\}/;
      markElements.forEach((mark) => {
        let colorMarkExecArr = colorMark.exec(mark.innerText);
        if (colorMarkExecArr) {
          mark.innerHTML = mark.innerHTML.replace(colorMarkExecArr[0], "");
          mark.classList.add(`cmx-highlight-${colorMarkExecArr[1]}`);
        }
      });
    });
    __publicField(this, "postProcess", (container, t) => {
      this.format(container);
    });
  }
};

// src/utils/postProcess/splitCells.ts
function splitCells(text) {
  let rows = text.split("\n");
  let cells = [];
  rows.forEach((row, index) => {
    if (index === 1) {
      return;
    }
    row = row.trim();
    row.startsWith("|") && (row = row.substring(1));
    row.endsWith("|") && (row = row.substring(0, row.length - 1));
    row.split(/(?:(?<!\\)|(?<=(?<!\\)(?:\\{2})+))\|/).forEach((cell) => {
      cells.push(cell);
    });
  });
  return cells;
}

// src/utils/postProcess/getEscapedDelims.ts
function getEscapedDelims(text, openingDelim, closingDelim) {
  let restrictedRanges = getRestrictedRanges(text);
  let indexes = [];
  openingDelim.lastIndex = 0;
  closingDelim.lastIndex = 0;
  for (let openingMatch = openingDelim.exec(text), i = 0; openingMatch; openingMatch = openingDelim.exec(text)) {
    let [all, escaper, target, slippedBackslash, next] = openingMatch.indices;
    if (restrictedRanges.some((range) => range[0] <= all[0] && range[1] >= all[1])) {
      continue;
    }
    closingDelim.lastIndex = all[1];
    if (escaper || slippedBackslash || next) {
      indexes.push(i);
      openingDelim.lastIndex = target[0] + 1;
      i++;
      continue;
    }
    i++;
    for (let closingMatch = closingDelim.exec(text); closingMatch || (openingDelim.lastIndex = text.length, false); closingMatch = closingDelim.exec(text)) {
      let [all2, escaper2, nonEscaper, target2, slippedBackslash2] = [...closingMatch.indices];
      if (restrictedRanges.some((range) => range[0] <= all2[0] && range[1] >= all2[1])) {
        continue;
      }
      if (escaper2 || slippedBackslash2) {
        indexes.push(i);
        closingDelim.lastIndex = target2[0] + 1;
        i++;
        continue;
      }
      i++;
      openingDelim.lastIndex = all2[1];
      break;
    }
  }
  return indexes;
}

// src/utils/postProcess/getDelimiterFromPreview.ts
function getDelimiterFromPreview(text, rawText, delimQuery) {
  var _a, _b, _c, _d, _e, _f, _g;
  let newLineChar = /(<br>\n?)\1+/g;
  let htmlTagRegExp = /<[\w\d\-]+(?: *[\w\d\-]+(?:=(?:"[^"]*")|(?:'[^']*'))?)*>/g;
  let currentLineEndOffset = (_b = (_a = newLineChar.exec(text)) == null ? void 0 : _a.index) != null ? _b : text.length;
  let currentTagExecArr = htmlTagRegExp.exec(text);
  let currentTagRange = [
    (_c = currentTagExecArr == null ? void 0 : currentTagExecArr.index) != null ? _c : text.length,
    htmlTagRegExp.lastIndex || text.length
  ];
  let { openingDelim, closingDelim, raw } = delimQuery;
  let escapedIndexes = getEscapedDelims(rawText, raw.openingDelim, raw.closingDelim);
  let delimPosCollection = [];
  openingDelim.lastIndex = 0;
  closingDelim.lastIndex = 0;
  for (let openingMatch = openingDelim.exec(text), lastIndex = openingDelim.lastIndex, i = 0; openingMatch; openingMatch = openingDelim.exec(text), lastIndex = openingDelim.lastIndex) {
    let delimPos = [0, 0, 0, 0];
    if (lastIndex > currentTagRange[1]) {
      htmlTagRegExp.lastIndex = lastIndex;
      currentTagRange = [
        ((_d = htmlTagRegExp.exec(text)) == null ? void 0 : _d.index) || text.length,
        htmlTagRegExp.lastIndex || text.length
      ];
    }
    if (lastIndex > currentTagRange[0] && lastIndex < currentTagRange[1]) {
      continue;
    }
    if (escapedIndexes[0] === i) {
      openingDelim.lastIndex = openingMatch.index + 1;
      escapedIndexes.shift();
      i++;
      continue;
    }
    if (lastIndex > currentLineEndOffset) {
      newLineChar.lastIndex = lastIndex;
      currentLineEndOffset = ((_e = newLineChar.exec(text)) == null ? void 0 : _e.index) || text.length;
    }
    closingDelim.lastIndex = lastIndex;
    [delimPos[0], delimPos[1]] = openingMatch.indices[0];
    i++;
    for (let closingMatch = closingDelim.exec(text); ; closingMatch = closingDelim.exec(text)) {
      lastIndex = closingDelim.lastIndex;
      if (!closingMatch || lastIndex > currentLineEndOffset) {
        openingDelim.lastIndex = delimPos[2] = delimPos[3] = currentLineEndOffset;
        currentLineEndOffset = ((_f = newLineChar.exec(text)) == null ? void 0 : _f.index) || text.length;
      } else if (lastIndex > currentTagRange[0] && lastIndex < currentTagRange[1]) {
        continue;
      } else if (escapedIndexes[0] === i) {
        closingDelim.lastIndex = closingMatch.index + 1;
        escapedIndexes.shift();
        i++;
        continue;
      } else {
        if (lastIndex > currentTagRange[1]) {
          htmlTagRegExp.lastIndex = lastIndex;
          currentTagRange = [
            ((_g = htmlTagRegExp.exec(text)) == null ? void 0 : _g.index) || text.length,
            htmlTagRegExp.lastIndex || text.length
          ];
        }
        [delimPos[2], delimPos[3]] = closingMatch.indices[0];
        openingDelim.lastIndex = lastIndex;
        i++;
      }
      break;
    }
    delimPosCollection.push(delimPos);
  }
  return delimPosCollection;
}

// src/utils/postProcess/getRestrictedRange.ts
function getRestrictedRanges(text) {
  let query = new RegExp("(\\\\)|`(?:[^`])+`|\\[\\[\\[?(?!\\[)(?:.|\\s)+?(?<!\\])\\]\\]|\\$\\$(?:.|\\s)*?\\$\\$|\\$(?!\\s|\\$).+?(?<!\\s)\\$", "gd");
  let restrictedRanges = [];
  for (let match = query.exec(text); match; match = query.exec(text)) {
    match[1] ? query.lastIndex += 1 : restrictedRanges.push(match.indices[0]);
  }
  return restrictedRanges;
}

// src/utils/getTextAtLine.ts
function getTextAtLine(text, lineStart, lineEnd) {
  return text.split("\n").slice(lineStart, lineEnd + 1).join("\n");
}

// src/utils/replaceStringAtPos.ts
function replaceStringByPos(text, replaceValue, from, to) {
  let replaceArea = new RegExp(`.{${to - from}}`, "ys");
  replaceArea.lastIndex = from;
  return text.replace(replaceArea, replaceValue);
}

// src/utils/postProcess/iterDelimReplacement.ts
function iterDelimReplacement(contentEl, rawText, delimQuery, tagName, excludedSelector, isTableCell) {
  isTableCell && tagName == "spoiler" && (rawText = "");
  let excludedContents = [];
  let excludedEl = contentEl.querySelectorAll(excludedSelector);
  excludedEl.length && excludedEl.forEach((el) => {
    excludedContents.push(el.innerHTML);
    el.innerHTML = "";
  });
  let sanitizedText = contentEl.innerHTML;
  let ranges = getDelimiterFromPreview(sanitizedText, rawText, delimQuery);
  if (ranges.length) {
    let delimLength = delimQuery == null ? void 0 : delimQuery.length;
    let lengthA = tagName.length + 2 - delimLength;
    let lengthB = tagName.length + 3;
    let i = 0;
    ranges.forEach((value) => {
      sanitizedText = replaceStringByPos(sanitizedText, `<${tagName}>`, value[0] + i, value[1] + i);
      i += lengthA;
      sanitizedText = replaceStringByPos(sanitizedText, `</${tagName}>`, value[2] + i, value[3] + i);
      i = value[2] == value[3] ? i + lengthB : i + lengthB - delimLength;
    });
  }
  ;
  contentEl.innerHTML = sanitizedText;
  excludedContents.forEach((content, index) => {
    contentEl.querySelectorAll(excludedSelector)[index].innerHTML = content;
  });
}

// src/utils/postProcess/getBlockquoteSections.ts
function getBlockquoteSections(text, isCallout) {
  let blockquoteDelim = /^ *>/;
  let sections = [];
  text.split("\n").forEach((text2) => {
    let level = 0;
    while (blockquoteDelim.test(text2) && ++level) {
      text2 = text2.replace(blockquoteDelim, "");
    }
    text2 = text2.trimStart();
    sections.push({
      text: text2,
      level
    });
  });
  loop1: for (let i = 0, mergePrevious = false; i < sections.length; ) {
    let currentLine = sections[i];
    if (isCallout && i === 0) {
      i++;
      continue;
    }
    if (/^```/.test(currentLine.text)) {
      let k = 1;
      while (sections[i + k]) {
        let { level, text: text2 } = sections[i + k++];
        if (text2 === "" && level < currentLine.level || /^``` *$/.test(text2) && level == currentLine.level) {
          break;
        }
      }
      sections.splice(i, k), mergePrevious && (mergePrevious = false);
      continue loop1;
    } else if (/^\$\$/.test(currentLine.text)) {
      let k = 1;
      while (sections[i + k]) {
        let { level, text: text2 } = sections[i + k++];
        if (text2 === "" && level < currentLine.level && k-- || /^\$\$ *$/.test(text2) && level == currentLine.level) {
          break;
        }
      }
      if (k !== 1) {
        sections.splice(i, k), mergePrevious && (mergePrevious = false);
        continue loop1;
      }
    } else if (currentLine.text === "") {
      sections.splice(i, 1), mergePrevious && (mergePrevious = false);
      continue loop1;
    }
    mergePrevious && sections[i - 1].level >= currentLine.level && (sections[i - 1].text += `
${sections.splice(i, 1)[0].text}`, i--);
    i++, mergePrevious || (mergePrevious = true);
  }
  return sections;
}

// src/postProcessor/ExtendedFormattingPostProcessor.ts
var ExtendedFormattingPostProcessor = class {
  constructor(workspace) {
    __publicField(this, "view");
    __publicField(this, "workspace");
    __publicField(this, "targetedElements", "p, li, h1, h2, h3, h4, h5, h6, .callout-title-inner");
    __publicField(this, "excludedSelector", "code, a.internal-link");
    __publicField(this, "postProcess", (container, ctx) => {
      var _a, _b, _c, _d, _e, _f, _g;
      let sectionInfo = ctx.getSectionInfo(container);
      if (sectionInfo) {
        let rawTextData = getTextAtLine(sectionInfo.text, sectionInfo.lineStart, sectionInfo.lineEnd);
        let firstChild = container.firstElementChild;
        if ((firstChild == null ? void 0 : firstChild.tagName) == "TABLE") {
          splitCells(rawTextData).forEach((rawText, i) => {
            this.format(container.querySelectorAll("td, th")[i], rawText, true);
          });
        } else if ((firstChild == null ? void 0 : firstChild.tagName) == "BLOCKQUOTE") {
          getBlockquoteSections(rawTextData, false).forEach((section, i) => {
            this.format(container.querySelectorAll(this.targetedElements)[i], section.text);
          });
        } else if (firstChild == null ? void 0 : firstChild.classList.contains("callout")) {
          getBlockquoteSections(rawTextData, true).forEach((section, i) => {
            this.format(container.querySelectorAll(this.targetedElements)[i], section.text);
          });
        } else {
          container.querySelectorAll(this.targetedElements).forEach((contentEl) => {
            this.format(contentEl, rawTextData);
          });
        }
        container.querySelectorAll("spoiler").forEach((el) => {
          el.addEventListener("click", (event) => {
            let spoiler = event.currentTarget;
            spoiler.hasClass("cmx-revealed") ? spoiler.removeClass("cmx-revealed") : spoiler.addClass("cmx-revealed");
          });
        });
      } else {
        let cmEditor = (_e = (_b = (_a = this.view) == null ? void 0 : _a.editor) == null ? void 0 : _b.cm) != null ? _e : (_d = (_c = this.workspace._["quick-preview"].find((evtRef) => {
          var _a2, _b2;
          return ((_a2 = evtRef.ctx) == null ? void 0 : _a2.hasOwnProperty("editMode")) && ((_b2 = evtRef.ctx) == null ? void 0 : _b2.path) == ctx.sourcePath;
        })) == null ? void 0 : _c.ctx) == null ? void 0 : _d.editMode.cm;
        if (container.classList.contains("table-cell-wrapper")) {
          let tableBlock = cmEditor.docView.children.find((el) => {
            var _a2;
            return ((_a2 = el.widget) == null ? void 0 : _a2.containerEl) == ctx.containerEl;
          });
          let tableCells = (_f = tableBlock == null ? void 0 : tableBlock.widget) == null ? void 0 : _f.cellChildMap.keys();
          for (let cell of tableCells) {
            if (cell.contentEl == ctx.el) {
              this.format(container, cell.text, true);
              break;
            }
          }
        } else if (ctx.containerEl.classList.contains("cm-callout")) {
          let calloutBlock = cmEditor.docView.children.find((el) => {
            var _a2;
            return ((_a2 = el.widget) == null ? void 0 : _a2.containerEl) == ctx.containerEl;
          });
          let calloutText = (_g = calloutBlock == null ? void 0 : calloutBlock.widget) == null ? void 0 : _g.text;
          getBlockquoteSections(calloutText, true).forEach((section, i) => {
            this.format(container.querySelectorAll(this.targetedElements)[i], section.text);
          });
        }
      }
    });
    this.view = workspace.activeEditor;
    this.workspace = workspace;
  }
  format(contentEl, rawText, isTableCell) {
    postProcessorDelimRegExps.forEach((delimQuery, tagName) => {
      iterDelimReplacement(contentEl, rawText, delimQuery, tagName, this.excludedSelector, isTableCell);
    });
  }
};

// main.ts
var ExtendedMarkdownSyntax = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadData();
    this.registerEditorExtension([
      extendedFormattingField,
      customHighlightField
    ]);
    this.registerEditorExtension([
      extendedFormattingPlugin,
      customHighlightPlugin,
      alignerPlugin,
      (0, import_view10.drawSelection)()
    ]);
    this.registerMarkdownPostProcessor(new ExtendedFormattingPostProcessor(this.app.workspace).postProcess);
    this.registerMarkdownPostProcessor(new CustomHighlightPostProcessor().postProcess);
    this.registerMarkdownPostProcessor(new AlignerPostProcessor().postProcess);
    console.log("Load Extended Markdown Syntax");
  }
  onunload() {
    console.log("Unload Extended Markdown Syntax");
  }
};
